<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1.1 题目一
    // const promise1 = new Promise((resolve, reject) => {
    //   console.log('promise1')
    // })

    // console.log('1', promise1)

    // 1.2 题目二
    // const promise = new Promise((resolve, reject) => {
    //   console.log('1');
    //   resolve('success');
    //   console.log('2')
    // })

    // promise.then(() => {
    //   console.log('3')
    // })

    // console.log('4')

    // 执行结果 1 2 4 3

    // 1.3 题目三

    // const promise = new Promise((resolve, reject) => {
    //   console.log('1')
    //   console.log('2')
    // })

    // promise.then(() => {
    //   console.log('3')
    // })

    // console.log('4')

    // 执行结果  1 2 4

    // 和题目二相似，只不过在 promise 中 并没有 resolve 或者 reject   ****** 没有所以没有被执行
    // 因此 promise.then 并不会执行，它只有在被改变了状态之后才会执行

    // 1.4 题目四

    // const promise1 = new Promise((resolve, reject) => {
    //   console.log('promise1')
    //   resolve('resolve1')
    // })
    
    // const promise2 = promise1.then((res) => {
    //   console.log(res)
    // })

    // console.log('1', promise1)
    // console.log('2', promise2)

    // 执行结果  'promise1'
    // '1' Promise{<fulfilled>: "resolve1"}
    // '2' Promise{<pending>}
    // 'resolve1'

    // 1.5 题目五
    
    // const fn = () => (new Promise((resolve, reject) => {
    //   console.log(1);
    //   resolve('success')
    // }))

    // fn().then(res => {
    //   console.log(res)
    // })

    // console.log('start')
    
    // 执行结果
    // 1
    // 'start'
    // 'success'

    // 1.6 题目六
    // const fn = () => new Promise((resolve, reject) => {
    //   console.log(1)
    //   resolve('success')
    // })

    // console.log('start')

    // fn().then((res) => {
    //   console.log(res)
    // })

    // 执行结果
    // 'start'
    //  1
    // 'success'

    // Promise 结合 setTimeout
    // 2.1 题目一

    // console.log('start')
    
    // setTimeout(() => {
    //   console.log('time')
    // }, 0)

    // Promise.resolve().then((res) => {
    //   console.log('resolve')
    // })

    // console.log('end')

    // 过程分析
    // 刚开始 整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出 start 和 end。
    // setTimeout 作为一个宏任务被放入宏任务队列 （下一个） ******
    // Promise.then 作为一个微任务被放入微任务队列
    // 本次宏任务执行完，检查微任务，发现 Promise.then，执行它
    // 接下来进入下一个宏任务，发现 setTimeout， 执行

    // 执行结果
    // 'start'
    // 'end'
    // 'resolve'
    // 'time'

    // 2.2 题目二
    // const promise = new Promise((resolve, reject) => {
    //   console.log(1)
    //   setTimeout(() => {
    //     console.log('timeStart')
    //     resolve('success')
    //     console.log('timeEnd')
    //   }, 0)
    //   console.log(2)
    // })

    // promise.then((res) => {
    //   console.log(res)
    // })

    // console.log(4)
    
    // 执行结果
    // 1
    // 2
    // 4
    // 'timerStart'
    // 'timeEnd'
    // 'success'

    // 2.3 题目三
    
    // 第一道
    // setTimeout(() => {
    //   console.log('timer1');
    //   setTimeout(() => {
    //     console.log('timer3')
    //   }, 0)
    // }, 0)
    // setTimeout(() => {
    //   console.log('timer2')
    // }, 0)
    // console.log('start')

    // 执行结果
    // 'start'
    // 'timer1'
    // 'timer2'
    // 'timer3'

    // 第二道
    // setTimeout(() => {
    //   console.log('timer1');
    //   Promise.resolve().then(() => {
    //     console.log('promise')
    //   })
    // }, 0)
    // setTimeout(() => {
    //   console.log('timer2')
    // }, 0)
    // console.log('start')

    // 执行结果
    // 'start'
    // 'timer1'
    // 'promise'
    //  timer2

    // 2.4 题目四
    // Promise.resolve().then(() => {
    //   console.log('promise1');
    //   const timer2 = setTimeout(() => {
    //     console.log('timer2')
    //   }, 0)
    // });
    // const timer1 = setTimeout(() => {
    //   console.log('timer1')
    //   Promise.resolve().then(() => {
    //     console.log('promise2')
    //   })
    // }, 0)
    // console.log('start');

    // 执行结果
    // 'start'
    // 'promise1'
    // 'timer1'
    // 'promise2'
    // 'timer2'

    // 2.5 题目五    *******
    
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve('success')
    //   }, 1000)
    // })

    // const promise2 = promise1.then(() => {
    //   throw new Error('error!!!')
    // })

    // console.log('promise1', promise1)
    // console.log('promise2', promise2)

    // setTimeout(() => {
    //   console.log('promise1', promise1)
    //   console.log('promise2', promise2)
    // }, 2000)

    // 我觉得 抛出 error 之后不会再继续往下执行了 // 错误的想法，因为事实是还会往下执行
    // 我的答案
    // 'promise1' promise1{<pending>}
    // 'promise2' promise2{<pending>}
    // 'error!!!!'

    // 正确的答案
    // 'promise1' Promise{<pending>}
    // 'promise2' Promise{<pending>}
    // Uncaugth (in promise) Error: error!!!!   // 解释：抛出了一个错误，且将promise2的状态设置为了 rejected
    // 'promise1' Promise{<fulfilled>: 'success'}
    // 'promise2' Promise{<rejected>: Error: error!!!}

    // 2.6 题目六

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("success");
    //     console.log("timer1");
    //   }, 1000);
    //   console.log("promise1里的内容");
    // });
    // const promise2 = promise1.then(() => {
    //   throw new Error("error!!!");
    // });
      // console.log("promise1", promise1);
      // console.log("promise2", promise2);
    // setTimeout(() => {
    //   console.log("timer2");
    //   console.log("promise1", promise1);
    //   console.log("promise2", promise2);
    // }, 2000);

    // 执行结果
    // 'promise1里的内容'
    // 'promise1' Promise{<pending>}
    // 'promise2' Promise{<pending>}
    // 'timer1'
    // Uncaught (in promise) Error: error!!!
    // 'timer2'
    // 'promise1' Promise{<fulfilled>: 'success'}
    // 'promise2' Promise{<rejected>: Error: error!!!}

    // Promise 中的 then、catch、finally
    // .then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传   ****  
    // .finally 方法 也是返回一个 Promise，他在 Promise 结束的时候，无论结果为 resolved 还是 rejected 都会执行里面的回调函数    ****

    // 3.1 题目一

    // const promise = new Promise((resolve, reject) => {
    //   resolve('success1')
    //   reject('error')
    //   resolve('success2')
    // })

    // promise.then((res) => {
    //   console.log('then：', res)
    // }).catch((res) => {
    //   console.log('then：', res)
    // })
    // 我的答案  // 错误的想法： 以为多个 resovle, reject 混合后会依次执行
    // 'then: ' 'success1'
    // 'catch: ' 'error'
    // 'then: ' 'success2'

    // 解释：
    // 构造函数中 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用。***Promise的状态一经改变就不能再改变***
    // 执行结果
    // 'then：success1'

    // 3.2  题目二
    // 我的答案    // 错误的想法， 以为 resovle 对应的就是 then，reject 对应的是 catch，并且只会执行一次，其实后面还有点的，属于链式执行  ***
    // 'catch: "error"'

    // const promise = new Promise((resolve, reject) => {
    //   reject('error')
    //   resolve('success')
    // })

    // promise.then((res) => {
    //   console.log('then1：', res)
    // }).then((res) => {
    //   console.log('then2：', res)
    // }).catch((err) => {
    //   console.log('catch：', err)
    // }).then((res) => {
    //   console.log('then3：', res)
    // })

    
    // 执行结果
    // 'catch：' 'error'
    // 'then3：' undefined
    
    // 解释：
    // 至于 then3 也会被执行，那是因为catch() 也会返回一个 Promise，且由于这个Promise 没有返回值，所以打印出来的是 undefined

    // 3.3  题目3
    // 我的答案  错误的想法 // 以为 catch 不执行，那么后面的then 也不会执行   ****
    // 1

    // Promise.resolve(1).then((res) => {
    //   console.log(res)
    //   return 2
    // }).catch((err) => {
    //   return 3
    // }).then((res) => {
    //   console.log(res)
    // })

    // 执行结果
    // 1
    // 2

    // 3.4 题目4
    // Promise.reject(1)
    // .then(res => {
    //   console.log(res);
    //   return 2;
    // })
    // .catch(err => {
    //   console.log(err);
    //   return 3
    // })
    // .then(res => {
    //   console.log(res);
    // });

    // 执行结果
    // 1
    // 3

    // 3.5 题目5

    // const promise = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     console.log('timer')
    //     resolve('success')
    //   }, 1000)
    // })
    // const start = Date.now();

    // promise.then((res) => {
    //   console.log(res, Date.now() - start)
    // })

    // promise.then((res) => {
    //   console.log(res, Date.now() - start)
    // })
    // 我的结果 // 错误的想法以为不会执行，以为promise的内部状态，多次调用 promise.then()，相当于多次改变状态，其实不是         *******
    // 分析过程  start 1597025626949  // 疑惑的地方，以promise.then 方式写的两个，会不会都执行，还是只执行一个，我们知道链式调用，是会都执行的
    // 'timer'
    // 'success', 1001

    // 执行结果
    // 'timer'
    // 'success' 1001
    // 'success' 1002

    // Promise的 .then 或者 .catch 可以被调用多次

    // 3.6 题目六      

    // Promise.resolve().then(() => {
    //   return new Error('error!!!')
    // }).then(res => {
    //   console.log('then：', res)
    // }).catch(err => {
    //   console.log('catch：', err)
    // })

    
    // 执行结果
    // 'then：' Error: error!!!
    
    // 解析
    // 任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的 return new Error('error!!!') 也被包裹成了 return Promise.resolve(new Error('error!!!'))
    
    // 3.7 题目七           ****
    
    // const promise = Promise.resolve().then(() => {
    //   return promise
    // })
    // promise.catch(console.err)

    // 执行结果
    // Chaining cycle detected for promise #<Promise>

    // 分析
    // .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环

    // 3.8 题目八    *******
      
    // Promise.resolve(1)
    //   .then(2)
    //   .then(Promise.resolve(3))
    //   .then(console.log)

    // 执行结果
    // 1
    // 分析
    // 第一个 then 和 第二个 then 中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个 then 里。
    // 为什么会直接传到最后一个里面了呢

    // 3.9 题目九      ****
    // Promise.reject('err!!!')
    //   .then((res) => {
    //     console.log('success', res)
    //   }, (err) => {  // 第二个参数相当于是catch
    //     console.log('error', err)   // 这里并没有返回 Promise.reject 所以 下面的catch 不会执行
    //   }).catch(err => {
    //     console.log('catch', err)
    //   })

    // 执行结果
    // 'error' 'err!!!'

    // Promise.reject('err!!!')
    //   .then((res) => {
    //     console.log('success', res)
    //   }).catch(err => {
    //     console.log('catch', err)
    //   })
    
    // 执行结果
    // 'catch' 'err!!!'

    
    // Promise.resolve()
    //   .then(function success(res) {
    //     throw new Error('error!!!')
    //   }, function fail1(err) {
    //     console.log('fail1', err)
    //   }).catch(function fail2(err) {
    //     console.log('fail2', err)
    //   })

    // 我的答案    // 错误的想法，以为控制台还是会报错，其实已经不会了         ****
    // Uncatghth Error: 'error!!!'
    // 'fail2' 'error!!!'

    // 执行结果
    // 分析 报错直接被捕获到了
    // fail2 Error: error!!!
    //             at success (promise.html:468)

    // 3.10 题目10           **** 和  finally() 这个单词本身的意思没什么关系
    // 关于 .finally(） 的知识点
    // 1、.finally()方法不管Promise对象最后的状态如何都会执行
    // 2、.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的
    // 3、它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。
    
    // 3.10.1
    // Promise.resolve('1')
    // .then(res => {
    //   console.log(res)
    // })
    // .finally(() => {
    //   console.log('finally')
    // })

    // Promise.resolve('2')
    //   .finally(() => {
    //     console.log('finally2')
    //     return '我是finaslly2返回的值'
    //   })
    //   .then(res => {
    //     console.log('finally2后面的then函数', res)
    //   })

    // 我的答案  // 我认为 finally 写法即使写在 then 之前，但是执行结果应该还是放在 then 后面的
    // '1'
    // 'finally'
    // 'finally2 后面的then 函数' 2
    // 'finally2'

    // 执行结果
    // '1'
    // 'finally2'
    // finally
    // finally2 后面的then函数  '2'

    // 解释 这两个 Promise 的 .finally 都会执行，且就算 finally2 返回了新的值，它后面的 then() 函数接收到的结果却还是 '2'
    
    // 3.10.2

    // Promise.resolve('1')
    //   .finally(() => {
    //     console.log('finally1')
    //     throw new Error('我是finally中抛出的异常')
    //   })
    //   .then(res => {
    //     console.log('finally后面的then函数', res)
    //   })
    //   .catch(err => {
    //     console.log('捕获错误', err)
    //   })

    // 执行结果
    // 'finally1'
    // '捕获错误' Error: 我是 finally 中抛出的异常

    // 3.10.3
    // function promise1 () {
    //   let p = new Promise((resolve) => {
    //     console.log('promise1');
    //     resolve('1')
    //   })
    //   return p;
    // }
    // function promise2 () {
    //   return new Promise((resolve, reject) => {
    //     reject('error')
    //   })
    // }
    // promise1()
    //   .then(res => console.log(res))
    //   .catch(err => console.log(err))
    //   .finally(() => console.log('finally1'))

    // promise2()
    //   .then(res => console.log(res))
    //   .catch(err => console.log(err))
    //   .finally(() => console.log('finally2'))


    // 执行结果
    // 'promise1'
    // 1
    // 'error'
    // 'finally1'
    // 'finally2'

    // 解释：
    // 链式调用后面的内容需要等前一个调用执行完才会执行。
    // **************就像是这里的 finally() 会等promise1().then() 执行完才会将 finally() 加入微任务队列，其实如果这道题中你把 finally() 
    // 换成是 then() 也是这样的**************

    // 4. Promise 中 的 all 和 race
    // .all() 的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。
    // .race() 的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃

    // 4.1 题目一
    // function runAsync (x) {
    //   const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    //   return p
    // }

    // Promise.all([runAsync(1), runAsync(2), runAsync(3)])
    //   .then(res => console.log(res))
    
    // 执行结果
    // 1
    // 2
    // 3
    // [1,2,3]

    // 4.2 题目二          ****************

    // function runAsync (x) {
    //   const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    //   return p
    // }
    // function runReject (x) {
    //   const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
    //   return p
    // }
    // Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
    //   .then(res => console.log(res))
    //   .catch(err => console.log(err))

    // 我的答案     // 错误的想法，以为即使异步操作中有异常，仍旧会进入.then() 中， 第二个是明明rej(`Error: ${x}`, console.log(x))
                   // 明明后一个参数是一个执行的脚本，为什么不会再次执行呢，只执行一次
    // 1
    // 3
    // 2
    // 4
    // 4
    // Error:4
    // [1,3,2,Error:4]


    // 执行结果
    // 1
    // 3
    // 2
    // Error: 2
    // 4

    // 解释：
    // .catch 是会捕获最先的那个异常，在这道题目中最先的异常就是 runReject(2)的结果
    // 另外，如果一组异步操作中有一个异常都不会进入.then() 的第一个回调函数参数中。

    // 4.3 题目三
    // .race() 方法，只会获取最先执行完成的那个结果，其他的异步任务虽然也会继续进行下去，不过race已经不管哪些任务的结果了

    // function runAsync (x) {
    //   const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    //   return p
    // }
    // Promise.race([runAsync(1), runAsync(2), runAsync(3)])
    //   .then(res => console.log('result: ', res))
    //   .catch(err => console.log(err))

    // 执行结果
    // 1
    // 'result：' 1
    // 2
    // 3

    // 4.4 题目四          ******
    // function runAsync(x) {
    //   const p = new Promise(r =>
    //     setTimeout(() => r(x, console.log(x)), 1000)
    //   );
    //   return p;
    // }
    // function runReject(x) {
    //   const p = new Promise((res, rej) =>
    //     setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x)
    //   );
    //   return p;
    // }
    // Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
    //   .then(res => console.log("result: ", res))
    //   .catch(err => console.log(err));


    // 执行结果   // 即使出现异常还是会继续往下执行的
    // 0
    // ‘Error: 0’
    // 1
    // 2
    // 3

    // 5. async/await 的几道题  

    // 5.1 题目一             ************

    // async function async1() {
    //   console.log("async1 start");
    //   await async2();
    //   console.log("async1 end");
    // }
    // async function async2() {
    //   console.log("async2");
    // }
    // async1();
    // console.log('start')

    // 我的答案  // 错误的想法， 完完全全错误了
    // 'async1 start'
    // 'async1 end'
    // 'start'
    // 'async2'

    // 执行结果
    // 'async1 start'
    // 'async2'
    // 'start'
    // 'async1 end'

    // 重要解释：
    // ***** 紧跟着await 后面的语句相当于放到了 new Promise 中，****下一行及之后的语句****相当于放在Promise.then 中

    // 上面的代码转换，那么就转换成下面
    // async function async1() {
    //   console.log("async1 start");
    // 原来代码
    // await async2();
    // console.log("async1 end"); 
  
  // 转换后代码
    // new Promise(resolve => {
    //   console.log("async2")
    //   resolve()
    //   }).then(res => console.log("async1 end"))
    // }
    // async function async2() {
    //   console.log("async2");
    // }
    // async1();
    // console.log("start")

  // 5.2  题目二
  
  // async function async1() {
  //   console.log("async1 start");
  //   await async2();
  //   console.log("async1 end");
  // }
  // async function async2() {
  //   setTimeout(() => {
  //     console.log('timer')
  //   }, 0)
  //   console.log("async2");
  // }
  // async1();
  // console.log("start")

  // 执行结果
  // 'async1 start'
  // 'async2'
  // 'start'
  // 'async1 end'
  // 'timer'


  // 5.3 题目三
//   async function async1() {
//   console.log("async1 start");
//   await async2();
//   console.log("async1 end");
//   setTimeout(() => {
//     console.log('timer1')
//   }, 0)
// }
// async function async2() {
//   setTimeout(() => {
//     console.log('timer2')
//   }, 0)
//   console.log("async2");
// }
// async1();
// setTimeout(() => {
//   console.log('timer3')
// }, 0)
// console.log("start")


  // 执行结果
  // 'async1 start'
  //  timer2 被挂起 // 'async2'  // timer3 被挂起
  // 'start'
  // 'async1 end' // timer1 被挂起
  // 'timer2'
  // 'timer3'
  // 'timer1'

  // 5.4 题目4

  // async function fn() {
  //   return 123
  // }
  // fn().then(res => console.log(res))

  // 5.4 题目五                       ************

  // async function async1 () {
  //   console.log('async1 start');
  //   await new Promise(resolve => {
  //     console.log('promise1')
  //   })
  //   console.log('async1 success');
  //   return 'async1 end'
  // }
  // console.log('srcipt start')
  // async1().then(res => console.log(res))
  // console.log('srcipt end')

  // 我的答案    错误答案          // 误以为 await 后面的promise 是有返回值，会往下执行的
  // 'script start'
  // 'async1 start'
  // 'promise1'
  // 'script end'
  // 'async1 end'
  // 'async1 success'

  // 执行结果
  // 'script start'
  // 'async1 start'
  // 'promise1'
  // 'script end'

  // 5.6  题目六
//   async function async1 () {
//   console.log('async1 start');
//   await new Promise(resolve => {
//     console.log('promise1')
//     resolve('promise1 resolve')
//   }).then(res => console.log(res))
//   console.log('async1 success');
//   return 'async1 end'
// }
// console.log('srcipt start')
// async1().then(res => console.log(res))
// console.log('srcipt end')


  // 执行结果

  // 'script start'  // 挂起紧接着async1 后面的 then
  // 'async1 start'  
  // 'promise1'
  // 'script end'
  // 'promise1 resolve'
  // 'async1 success'
  // 'async1 end' 

  // 5.7 题目7

//   async function async1 () {
//   console.log('async1 start');
//   await new Promise(resolve => {
//     console.log('promise1')
//     resolve('promise resolve')
//   })
//   console.log('async1 success');
//   return 'async1 end'
// }
// console.log('srcipt start')
// async1().then(res => {
//   console.log(res)
// })
// new Promise(resolve => {
//   console.log('promise2')
//   setTimeout(() => {
//     console.log('timer')
//   })
// })



  // 执行结果
  // 'script start'
  // 'async1 start'
  // 'promise1'
  // 'promise2'
  // 'async1 success'
  // 'async1 end'
  // 'timer'

  // 5.8 题目八
//   async function async1() {
//   console.log("async1 start");
//   await async2();
//   console.log("async1 end");
// }

// async function async2() {
//   console.log("async2");
// }

// console.log("script start");

// setTimeout(function() {
//   console.log("setTimeout");
// }, 0);

// async1();

// new Promise(function(resolve) {
//   console.log("promise1");
//   resolve();
// }).then(function() {
//   console.log("promise2");
// });
// console.log('script end')


  // 执行结果
  // 'script start'
  // 挂起宏任务 setTimetout // 'async1 start'
  // 'async2'
  // 'promise1'
  // 'script end'
  // 'async1 end'
  // 'promise2'
  // 'setTimeout'

  // 5.9  题目九

//   async function testSometing() {
//   console.log("执行testSometing");
//   return "testSometing";
// }

// async function testAsync() {
//   console.log("执行testAsync");
//   return Promise.resolve("hello async");
// }

// async function test() {
//   console.log("test start...");
//   const v1 = await testSometing();
//   console.log(v1);
//   const v2 = await testAsync();
//   console.log(v2);
//   console.log(v1, v2);
// }

// test();

// var promise = new Promise(resolve => {
//   console.log("promise start...");
//   resolve("promise");
// });
// promise.then(val => console.log(val));

// console.log("test end...");


  // 我的疑惑点  async 里 return 'testingSomething' 和  async 里 return Promise.resolve('hello async') 的区别
  // 执行结果
  // 'test start...'
  // '执行testingsomething'
  // 'promise start...'
  // 'test end...'
  // 'testSomething'
  // '执行testAsync'
  // 'promise'
  // 'hello async'
  // 'testSomething' 'hello async'

  //  async 处理错误
  // 6.1 题目一 async 处理错误
  // 在async 中，如果 await 后面的内容是一个异常或者错误的话，会怎样呢？

  // async function async1 () {
  //   await async2();
  //   console.log('async1');
  //   return 'async1 success'
  // }
  // async function async2 () {
  //   return new Promise((resolve, reject) => {
  //     console.log('async2')
  //     reject('error')
  //   })
  // }
  // async1().then(res => console.log(res))


  // 执行结果
  // 'async2'
  // Uncaught (in promise) error

  // 第二种情况
//   async function async1 () {
//   console.log('async1');
//   throw new Error('error!!!')
//   return 'async1 success'
// }
// async1().then(res => console.log(res))

  // 执行结果
  // 'async1'
  // Uncaught (in promise) Error: error !!!

  // 6.2 题目二
  // 如果想要使得错误的地方不影响 async 函数后续的执行的话，可以使用 try catch
  
  // async function async1() {
  //   try {
  //     await Promise.reject('error!!!')
  //   } catch(e) {                                // 这里有 catch 所以 error!!! 会被执行
  //     console.log(e)
  //   }
  //   console.log('async1')
  //   return Promise.resolve('async1 success')
  // }

  //   async1().then(res => console.log(res))

  //   console.log('script start')

  // 执行结果
  // 'script start'
  // 'error!!!'
  // 'async1'
  // 'async1 success'

  // 7. 综合题

  // 7.1 题目一

//   const first = () => (new Promise((resolve, reject) => {
//     console.log(3);
//     let p = new Promise((resolve, reject) => {
//         console.log(7);
//         setTimeout(() => {
//             console.log(5);
//             resolve(6);
//             console.log(p)
//         }, 0)
//         resolve(1);
//     });
//     resolve(2);
//     p.then((arg) => {            // 这里因为不是 p 函数，所以就在 resolve(2) 之前就执行了 p ？？？？？？？********
//         console.log(arg);
//     });
// }));
// first().then((arg) => {
//     console.log(arg);
// });
// console.log(4);


  // 我的错误答案
  // 3
  // resolve(2) 微任务被挂起 继续执行   // 7
  // 宏任务被挂起  // resolve(1)  再一个微任务被挂起 // 4
  // 2
  // 1
  // 5
  // Promise{<resolved>}


  // 执行结果

  // 3
  // 7
  // 4
  // 1
  // 2
  // 5
  // Promise{<fulfilled>:1}

  // 7.2 题目二              *******
  // 我的错误答案          ****没有理解两个地方，一个是 await 之后语句相当于放在new Promise 中，下一行以及之后的语句相当于放在 promise.then 中
  // 如果 new Promise 中 没有 resolve ，那么下一行以及之后的语句都不会执行。第二个是两个宏任务，一个先一个后，但是如果先的宏任务的定时时间大于后一个，那么后一个先执行。
  // 'script start'
  // 'async1'   // 挂起第一个宏任务
  // 'promise1'  // 不会执行 'async1 end' // 挂起 async1.then
  // 'script end'
  // 挂起 Promise.then   // 挂起第二个宏任务
  // 'async1 success'
  // 1
  // timer1
  // timer2
  
//   const async1 = async () => {
//   console.log('async1');
//   setTimeout(() => {
//     console.log('timer1')
//   }, 2000)
//   await new Promise(resolve => {
//     console.log('promise1')
//   })
//   console.log('async1 end')
//   return 'async1 success'
// } 
// console.log('script start');
// async1().then(res => console.log(res));
// console.log('script end');
// Promise.resolve(1)
//   .then(2)
//   .then(Promise.resolve(3))
//   .catch(4)
//   .then(res => console.log(res))
// setTimeout(() => {
//   console.log('timer2')
// }, 1000)


  // 执行结果
  // 'script start'
  // 'async1'
  // 'promise1'
 //  'script end'
 //  1
  // 'timer2'
   // 'timer1'

  //  7.3 题目三      ******


//   const p1 = new Promise((resolve) => {
//   setTimeout(() => {
//     resolve('resolve3');
//     console.log('timer1')
//   }, 0)
//   resolve('resovle1');
//   resolve('resolve2');
// }).then(res => {
//   console.log(res)
//   setTimeout(() => {
//     console.log(p1)
//   }, 1000)
// }).finally(res => {
//   console.log('finally', res)
// })


  // 执行结果

  // 'resovle1'
  // 'finally' undefined
  // timer1
  // Promise{<fulfilled>:undefined}    // 时候最后的值，而不是曾经的值

  // 8 几道大厂的面试题

  // 8.1 使用 Promise 实现每隔1秒输出1，2，3

  let arr = [1,2,3]
  
  arr.reduce(
    (p, x) => { return p.then(() => new Promise((r) => setTimeout(() => r(console.log(x)), 1000)))}, Promise.resolve()
  )

  // 8.2 使用 Promise 实现红绿灯交替重复亮
  // 红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次。

  // 8.3 实现mergePromise 函数

  

  // 8.4 根据promiseA + 实现一个自己的promise

  // 8.5 封装一个异步加载图片的方法

  // 8.6 限制异步操作的并发个数并尽可能快的完成全部

  </script>
</body>
</html>

