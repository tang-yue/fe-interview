<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 题目一
        async function asyncFn1 () {
            console.log('asyncFn1 start')
            await asyncFn2()
            console.log('async1 end')   // 被放进微任务
        }

        async function asyncFn2 () {
            console.log('asyncFn2')
        }

        console.log('script start') 

        setTimeout(function () {
            console.log('setTimeout')      // 被放进宏任务
        }, 0)

        asyncFn1()    // 从这开始执行，并且执行完毕

        new Promise((resolve) => {
            console.log('Promise')
            resolve()
        }).then(() => {
            console.log('Promise.then')   // 被放进微任务
        })

        console.log('script end')
        
        // 执行结果
        'script start'
        'asyncFn1 start'
        'asyncFn2'
        'promise'
        'script end'
        'async1 end'
        'Promise.then'
        'setTimeout'

        // 题目二

        console.log('script start')

        async function async1() {
            await async2()
            console.log('async1 end')  // 跳出循环了，被放进了微任务
        }

        async function async2() {
            console.log('async2 end')
        }

        async1()

        setTimeout(function() {
            console.log('setTimeout')     // 被放进了宏任务
        }, 0)

        new Promise(resolve => {
            console.log('Promise')
            resolve()
        }).then(function() {
            console.log('promise1') // 微任务
        }).then(function() {
            console.log('promise2') // 微任务，疑惑的点，promise的状态一经改变就不会被第二次改变了吧，针对的是多个resolve
        })

        console.log('script end')

        // // 新版Chrome 的执行结果， 将’async1 end‘的打印结果提前了
        // 'script start'
        // 'async2 end'
        // 'promise'
        // 'script end'
        // 'async1 end' 
        // 'promise1'
        // 'promise2'
        // 'setTimeout'

        // 如果不提前的分析过程如下：
        
        // 题目二的变形，await 后面跟的是一个异步函数的调用
        
        console.log('script start')

        async function async1() {
            await async2()
            console.log('async1 end')
        }

        async function async2() {
            console.log('async2 end')
            return Promise.resolve().then(() => {    // 这里被当作是一个微任务，那await 后面的代码怎么办
                console.log('async2 end1')
            })
        }

        async1()

        setTimeout(function() {
            console.log('setTimeout')
        }, 0)

        new Promise(resolve => {
            console.log('Promise')
            resolve()
        }).then(function() {
            console.log('promise1') // 微任务
        }).then(function() {
            console.log('promise2')  // 微任务
        })

        console.log('script end')

        // 执行结果
        'script start'
        'async2 end'
        'Promise'
        'script end'
        'async2 end1'
        'promise1'
        'promise2'
        'async1 end'
        'setTimeout'

        // 分析结果如下：
        
    </script>
</body>
</html>